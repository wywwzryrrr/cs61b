# Gitlet Design Document

## Gitlet: A Git-like Version Control System built from scratch in Java

**Name**: zng.xee

## Classes and Data Structures

### Commit
Represents a Commit.

#### Fields

1. `String message`: The message that user input when committing.
2. `String timestamp`: The timestamp when committing a file, generated by a helper method.
3. `Stirng parent`: The parent commitUID.
4. `String secondParent`: The second parent commitUID.
5. `TreeMap<String, String> blob`: The snapshots of files of this commit.
6. `String UID`: The SHA-1 id of this commit


### Blob

#### Fields

1. `String content`: `Utils.readContentAsString(file)`
2. `String UID`: `Utils.sha1(content)`


### HelperMethods

All the helper methods used in Commands


### Commands

#### Core features

1. `init`: initialize gitlet repository.
2. `commit [message]`: to make a commit.
3. `add [filename]`: add a copy of file to staging area.
4. `rm [filename]`: add a copy of file to stage for removal, and clear the file in stage for addition if it exists.
5. `log`: print the commit UID, message and timestamp chronologically.
6. `global log`: like log, but the order is not considered.
7. `find [message]`: prints out the ids of all commits that have the given commit message, one per line.
8. `branch [branchname]`: create a new branch with the given name.
9. `rmbranch [branchname]`: remove the branch with the given name.
10. `status`: displays what branches currently exist, and marks the current branch with a *. Also displays what files have been staged for addition or removal.
11. `checkout`:  varies depending on input.
+ `checkoutFile [filename]`: change the file with the given filename to the version in head commit.
+ `checkoutCommitFile [commitUID, filename]`: change the file with the given filename to the version in the commit of given commitUID.
+ `checkoutBranch [branchname]`: change the CWD to the given branch's version.
12. `reset [commitUID]`: checkout all the file tracked by the given commitUID.
13. `merge [branchname]`: merge the files in two branches according to different situations.


## Persistence
```
CWD (dir)
 └── .gitlet/ (dir)
      ├── HEAD (file)
      ├── refs/ (dir)
      │   └── heads/ (dir)
      │       └── master (file)
      ├── blobs/ (dir)
      ├── commits/ (dir)
      └── stage/ (dir)
          ├── add (dir)
          └── remove (dir)
```

+ `HEAD` file: stores the current branch's path.
+ `heads` directory in `refs` : stores different branch; name is branch name, content is the commit id on the tip of the branch.
+ `blobs` directory: stores all Blob objects, name is sha-1 UID according to a file's content.
+ `commits` directory: stores all commits, name is commitUID, content is a TreeMap.
+ `stage` directory: staging area contains `add` and `remove` directory, witch represent stage for addition and stage for removal respectively.
+ `master`file: stores the latest commitUID


## Design and implementation Detail
+ A common commit should only have one parent, the `secondParent` parameter should be null. 
The `secondParent` parameter is specially designed for `mergeCommit` in `merge`.
+ The commitUID is stored in a directory called `COMMITS_DIR`. To track witch commit is the headCommit, just check the `HEAD_FILE`, which stores
the path of `MASTER_FILE`. The `MASTER_FILE` stores the latest commitUID.
+ A commit object has a TreeMap called `blob`, which takes files in `CWD` with absolute path as keys, and the values are files in `BLOBS_DIR`.
The files in `BLOBS_DIR` use their content after `SHA-1` method as their name. To get the blobFile in `BLOBS_DIR`, use`commit.getblob()`. This will return the
TreeMap of the Commit object. Then use `get(filePath)` to get the value, which is the `blobUID`. Then use `Utils.join(BLOBS_DIR, blobUID)` to get the blobFile.
To rewrite the content of a file, use `Utils.readObject(File object, blob.class)` to deserialize the
blobFile to `Blob` object, then use `Utils.writeContents(File object, Blob object.getContent())`. This is the key to implement `checkout [filename]` when required to overwrite the file
in a helper method called `overwriteFiles`.
+ For `checkout [commitUID] [filename]` just based on the `overwriteFiles` then iterate the TreeMap using `keySet()`,
which is implemented as a helper method named `overwriteAllFiles`.
  + For `checkout [branchname]` case would be simple using `overwriteAllFiles`.
+ For `merge`, my approach is to find the `splitPoint`, and then compare all the files in `splitPoint`, `headCommit`
and `branchCommit`. According to the comparison, it would react variously. To find the `splitPoint`, I wrote a method named
`findSplitPoint`, which takes `headCommit` and `branchCommit` as its parameter, using BFS to reach its goal. 
It uses a Queue named `commitQueue` to iterate commits, and two Hashsets `parentUIDs`, `visitedUIDs` would record the polled commits' UIDs simultaneously.
It would first iterate through `headCommit`, adding all the commits in it. When `commitQueue` is empty, both `commitQueue` and `visitedUIDs`
would be cleared. Like the first iteration, the second one would go through `branchCommit`, but this time it would stop once
it encounters the first commits that `parentsUIDs` has, which is the `splitPoint`.
  + My approach handling merge conflict is through the comparison in all the files in `headCommit`, `branchCommit`, and `splitPoint`.
  In the beginning, a helper method named `filePathsInCommit` gathers all the file paths in all three commits, then a boolean
  `mergeConlict` is acquiesced to be false and is put in a helper method called `handleMerge`. 
  Through iterating all the file paths, `handleMerge` get the blobUID of files in different commits through a helper method
  named `getBlobUID`. If a file does not exist in the commit, it would return null. All the case methods use `Object.equals`
  to compare, witch should be a robust way to handle null value.
    + The merge cases are charted below.
    + `B` -> `branchCommitUID`
    <br/>`H` -> `headCommitUID`
    <br/>`S` -> `splitPointUID`
    + | Cases | Condition<br/>Expression                  | Logical<br/>Condition                                  | Actions               | Rationale                                                                                                             | 
      |-------|-------------------------------------------|--------------------------------------------------------|-----------------------|-----------------------------------------------------------------------------------------------------------------------|
      | 1     | modified in `B`, not modified in `H`      | `H == S`<br/>&&<br/>`B != S`                           | `mergeCheckoutStage`  | The file is not modified in current branch, should merge the other branch modification directly.                      |
      | 2     | modified in `H`, not modified in `B`      | `H != S`&&`B == S`                                     | do nothing            | The file is not modified in other branch, should keep the modification in current branch.                             |
      | 3.1   | both not modified or modified identically | `H == B`                                               | do nothing            | The contents of two files are identical, should take no action.                                                       |
      | 3.2   | modified differently                      | `H != S`<br/>&&<br/>`B != S`<br/>&&<br/>`H != B`       | `recordMergeConflict` | The contents of two files are modified differently, should handle the conflict manually.                              |
      | 4     | only present in `H`                       | `S`== null<br/>&&<br/>`B`== null<br/>&&<br/>`H`!= null | do nothing            | The file is particular in current branch, should keep the file.                                                       |
      | 5     | only present in `B`                       | `S`== null<br/>&&<br/>`H`== null<br/>&&<br/>`B`!= null | `mergeCheckoutStage`  | The file is new in given branch, should should be merged to current branch.                                           |
      | 6     | deleted in `B`, not modified in `H`       | `H == S`<br/>&&<br/>`B`== null                         | `mergeRemoveUntrack`  | The file has been deleted in the given branch, while not been modified in the current branch, should add for removal. |
      | 7     | deleted in `H`, not modified in `B`       | `H`== null<br/>&&<br/>`B == S`                         | do nothing            | The file has been deleted in the current branch, should keep the deletion.                                            |
    + Specifically, a merge conflict would be encountered in `case3Part2`. My solution to merge conflict is to set the boolean `mergeConflict`
    into true, then call a helper method named `recordMergeConflict`. The method acquiesces to have blank content in `headFileContent`
    and `branchFileContent`. Only when the `headCommitBlobUID` or the `branchCommitUID` is not null should these two have contents.
    + For `log` in merged cases, my solution is judging if the given commit has two parents.